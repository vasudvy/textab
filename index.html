<!DOCTYPE html>
<html>
<head>
    <title>Textab Video Generator</title>
</head>
<body>
    <h1>Textab\</h1>
    
    <h2>Setup</h2>
    <form id="setupForm">
        <p>
            <label>OpenAI API Key:</label><br>
            <input type="password" id="apiKey" size="60" placeholder="sk-proj-...">
            <button type="button" onclick="testApiKey()">Test Key</button>
        </p>
        <div id="apiStatus"></div>
    </form>
    
    <hr>
    
    <h2>Create Your Video</h2>
    <form id="videoForm">
        <p>
            <label>Describe your video:</label><br>
            <textarea id="videoDescription" rows="8" cols="80" placeholder="Example: Create a 5-second video with blue background and white text saying 'Welcome to our product' that slides in from the left"></textarea>
        </p>
        
        <p>
            <button type="button" onclick="generateVideo()" id="generateBtn" disabled>Generate Video</button>
        </p>
    </form>
    
    <hr>
    
    <h2>Output</h2>
    <div id="status"></div>
    
    <div id="codeOutput" style="display:none;">
        <h3>Generated Remotion Code:</h3>
        <pre id="generatedCode"></pre>
    </div>
    
    <div id="videoOutput" style="display:none;">
        <h3>Your Video:</h3>
        <canvas id="videoCanvas" width="1280" height="720"></canvas>
        <br><br>
        <button onclick="downloadVideo()">Download Video</button>
    </div>

    <script>
        let userApiKey = '';
        let currentVideoData = null;

        async function testApiKey() {
            const apiKey = document.getElementById('apiKey').value.trim();
            
            if (!apiKey) {
                document.getElementById('apiStatus').innerHTML = '<p style="color:red;">Please enter your API key.</p>';
                return;
            }

            document.getElementById('apiStatus').innerHTML = '<p>Testing API key...</p>';

            try {
                const response = await fetch('https://api.openai.com/v1/models', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });

                if (response.ok) {
                    userApiKey = apiKey;
                    document.getElementById('apiStatus').innerHTML = '<p style="color:green;">✓ API key is valid and working!</p>';
                    document.getElementById('generateBtn').disabled = false;
                    // Store in sessionStorage for this session
                    sessionStorage.setItem('openai_api_key', apiKey);
                } else {
                    const errorData = await response.json();
                    document.getElementById('apiStatus').innerHTML = `<p style="color:red;">✗ API key error: ${errorData.error?.message || 'Invalid key'}</p>`;
                    document.getElementById('generateBtn').disabled = true;
                }
            } catch (error) {
                document.getElementById('apiStatus').innerHTML = '<p style="color:red;">✗ Network error. Please check your connection.</p>';
                document.getElementById('generateBtn').disabled = true;
            }
        }

        async function generateVideo() {
            const description = document.getElementById('videoDescription').value.trim();
            
            if (!description) {
                document.getElementById('status').innerHTML = '<p style="color:red;">Please describe your video.</p>';
                return;
            }

            if (!userApiKey) {
                document.getElementById('status').innerHTML = '<p style="color:red;">Please test your API key first.</p>';
                return;
            }

            document.getElementById('status').innerHTML = '<p>Generating your video...</p>';
            document.getElementById('codeOutput').style.display = 'none';
            document.getElementById('videoOutput').style.display = 'none';

            try {
                // Step 1: Generate Remotion code
                const remotionCode = await generateRemotionCode(description);
                
                // Display the generated code
                document.getElementById('generatedCode').textContent = remotionCode;
                document.getElementById('codeOutput').style.display = 'block';
                
                document.getElementById('status').innerHTML = '<p>Code generated! Rendering video...</p>';
                
                // Step 2: Render video
                await renderVideoFromCode(remotionCode);
                
                document.getElementById('status').innerHTML = '<p style="color:green;">✓ Video generated successfully!</p>';
                
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('status').innerHTML = '<p style="color:red;">Error: ' + error.message + '</p>';
            }
        }

        async function generateRemotionCode(description) {
            const systemPrompt = `You are an expert Remotion developer. Generate a complete, working Remotion React component based on user descriptions.

CRITICAL REQUIREMENTS:
1. Always import React, useCurrentFrame, useVideoConfig, and interpolate from 'remotion'
2. Export a default functional component
3. Use 30 FPS frame rate
4. Duration should be 30-300 frames (1-10 seconds)
5. Use proper frame-based animations with interpolate()
6. Include smooth transitions and professional styling
7. Make it visually appealing with good typography and colors
8. Handle responsive sizing using width/height from useVideoConfig
9. Return ONLY the complete React component code, no explanations

TEMPLATE STRUCTURE:
import React from 'react';
import { useCurrentFrame, useVideoConfig, interpolate } from 'remotion';

const MyVideo = () => {
  const frame = useCurrentFrame();
  const { width, height } = useVideoConfig();
  
  // Animation calculations using interpolate()
  const opacity = interpolate(frame, [0, 30], [0, 1]);
  const translateX = interpolate(frame, [0, 60], [-100, 0]);
  
  return (
    <div style={{
      width: width,
      height: height,
      backgroundColor: '#1a1a2e',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontFamily: 'Arial, sans-serif'
    }}>
      <div style={{
        opacity: opacity,
        transform: \`translateX(\${translateX}px)\`,
        color: 'white',
        fontSize: 48,
        fontWeight: 'bold',
        textAlign: 'center'
      }}>
        Your Content Here
      </div>
    </div>
  );
};

export default MyVideo;

ANIMATION EXAMPLES:
- Fade in: interpolate(frame, [0, 30], [0, 1])
- Slide in from left: interpolate(frame, [0, 60], [-200, 0])
- Slide in from right: interpolate(frame, [0, 60], [200, 0])
- Scale up: interpolate(frame, [0, 30], [0.5, 1])
- Rotate: interpolate(frame, [0, 120], [0, 360])
- Bounce: interpolate(frame, [0, 30], [0, 1], { extrapolateRight: 'clamp' })

STYLING GUIDELINES:
- Use modern colors and gradients
- Ensure good contrast for text
- Use appropriate font sizes (48px+ for main text)
- Center content properly
- Make animations smooth and professional
- Use box-shadow for depth when appropriate

Make the video engaging and professional looking.`;

            const userPrompt = `Create a Remotion video component for: "${description}"

Requirements:
- Make it visually stunning with smooth animations
- Use appropriate colors and typography
- Ensure all animations are frame-based using interpolate()
- Make it engaging and professional
- Duration should match the description or be 3-5 seconds if not specified
- Include proper easing and timing for animations`;

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${userApiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4',
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: userPrompt }
                    ],
                    max_tokens: 2000,
                    temperature: 0.7
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`OpenAI API error: ${errorData.error?.message || response.statusText}`);
            }

            const data = await response.json();
            return data.choices[0].message.content.trim();
        }

        async function renderVideoFromCode(remotionCode) {
            // Parse the code to extract animation parameters
            const codeAnalysis = analyzeRemotionCode(remotionCode);
            
            // Simulate rendering time
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            // Render the video on canvas
            await renderVideoToCanvas(codeAnalysis);
        }

        function analyzeRemotionCode(code) {
            // Extract key information from the generated code
            const analysis = {
                duration: 90, // default 3 seconds
                hasText: false,
                textContent: '',
                backgroundColor: '#1a1a2e',
                textColor: '#ffffff',
                fontSize: 48,
                hasAnimation: false,
                animationType: 'fade',
                animationParams: {}
            };

            // Parse duration from interpolate ranges
            const interpolateMatches = code.match(/interpolate\([^,]+,\s*\[0,\s*(\d+)\]/g);
            if (interpolateMatches) {
                const durations = interpolateMatches.map(match => {
                    const num = match.match(/\[0,\s*(\d+)\]/);
                    return num ? parseInt(num[1]) : 60;
                });
                analysis.duration = Math.max(...durations) * 1.5; // Extend for better demo
            }

            // Parse text content
            const textMatches = code.match(/['"`]([^'"`]{3,50}?)['"`]/g);
            if (textMatches && textMatches.length > 0) {
                analysis.hasText = true;
                // Find the longest text (likely the main content)
                analysis.textContent = textMatches.reduce((a, b) => a.length > b.length ? a : b).replace(/['"`]/g, '');
            }

            // Parse background color
            const bgColorMatch = code.match(/backgroundColor:\s*['"`]([^'"`]+)['"`]/);
            if (bgColorMatch) {
                analysis.backgroundColor = bgColorMatch[1];
            }

            // Parse text color
            const textColorMatch = code.match(/color:\s*['"`]([^'"`]+)['"`]/);
            if (textColorMatch) {
                analysis.textColor = textColorMatch[1];
            }

            // Parse font size
            const fontSizeMatch = code.match(/fontSize:\s*(\d+)/);
            if (fontSizeMatch) {
                analysis.fontSize = parseInt(fontSizeMatch[1]);
            }

            // Check for animations
            if (code.includes('interpolate')) {
                analysis.hasAnimation = true;
                
                if (code.includes('translateX') && code.includes('[-')) {
                    analysis.animationType = 'slideFromLeft';
                } else if (code.includes('translateX') && code.includes('[2')) {
                    analysis.animationType = 'slideFromRight';
                } else if (code.includes('translateY')) {
                    analysis.animationType = 'slideFromTop';
                } else if (code.includes('scale')) {
                    analysis.animationType = 'scale';
                } else if (code.includes('rotate')) {
                    analysis.animationType = 'rotate';
                } else if (code.includes('opacity')) {
                    analysis.animationType = 'fade';
                }
            }

            return analysis;
        }

        async function renderVideoToCanvas(analysis) {
            const canvas = document.getElementById('videoCanvas');
            const ctx = canvas.getContext('2d');
            
            let frameIndex = 0;
            const totalFrames = Math.min(analysis.duration, 180); // Cap at 6 seconds for demo
            
            function renderFrame() {
                // Clear canvas
                ctx.fillStyle = analysis.backgroundColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (analysis.hasText) {
                    ctx.fillStyle = analysis.textColor;
                    ctx.font = `${analysis.fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    let x = canvas.width / 2;
                    let y = canvas.height / 2;
                    let opacity = 1;
                    let scale = 1;
                    let rotation = 0;
                    
                    // Apply animations
                    if (analysis.hasAnimation) {
                        const progress = Math.min(1, frameIndex / 60); // 2 second animation
                        const easeProgress = easeInOutCubic(progress);
                        
                        switch (analysis.animationType) {
                            case 'slideFromLeft':
                                x = canvas.width / 2 + (1 - easeProgress) * -300;
                                break;
                            case 'slideFromRight':
                                x = canvas.width / 2 + (1 - easeProgress) * 300;
                                break;
                            case 'slideFromTop':
                                y = canvas.height / 2 + (1 - easeProgress) * -200;
                                break;
                            case 'scale':
                                scale = 0.3 + easeProgress * 0.7;
                                break;
                            case 'rotate':
                                rotation = easeProgress * Math.PI * 2;
                                break;
                            default: // fade
                                opacity = easeProgress;
                        }
                    }
                    
                    // Apply transformations
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.translate(x, y);
                    ctx.scale(scale, scale);
                    ctx.rotate(rotation);
                    
                    // Draw text
                    ctx.fillText(analysis.textContent || 'AI Generated Video', 0, 0);
                    
                    ctx.restore();
                }
                
                // Add frame counter
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '14px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(`Frame ${frameIndex + 1}/${totalFrames}`, canvas.width - 10, 20);
                
                frameIndex++;
                
                if (frameIndex < totalFrames) {
                    setTimeout(renderFrame, 33); // ~30 FPS
                } else {
                    // Animation complete
                    document.getElementById('videoOutput').style.display = 'block';
                    
                    // Create downloadable content
                    canvas.toBlob(function(blob) {
                        currentVideoData = blob;
                    });
                }
            }
            
            renderFrame();
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
        }

        function downloadVideo() {
            if (currentVideoData) {
                const url = URL.createObjectURL(currentVideoData);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ai-generated-video.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } else {
                alert('No video available for download');
            }
        }

        // Load stored API key on page load
        document.addEventListener('DOMContentLoaded', function() {
            const storedKey = sessionStorage.getItem('openai_api_key');
            if (storedKey) {
                document.getElementById('apiKey').value = storedKey;
                testApiKey();
            }
            
            // Pre-fill example
            document.getElementById('videoDescription').value = 'Create a 4-second video with a dark gradient background. Show the text "Welcome to the Future" in large white letters that slides in smoothly from the left side of the screen.';
        });
    </script>
</body>
</html>